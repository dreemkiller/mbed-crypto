/* Automatically generated by generate_psa_constant.py. DO NOT EDIT. */
#include "psa/crypto.h"

static const char *psa_strerror(psa_status_t status)
{
    switch (status) {
    case PSA_ERROR_BAD_STATE: return "PSA_ERROR_BAD_STATE";
    case PSA_ERROR_BUFFER_TOO_SMALL: return "PSA_ERROR_BUFFER_TOO_SMALL";
    case PSA_ERROR_COMMUNICATION_FAILURE: return "PSA_ERROR_COMMUNICATION_FAILURE";
    case PSA_ERROR_EMPTY_SLOT: return "PSA_ERROR_EMPTY_SLOT";
    case PSA_ERROR_HARDWARE_FAILURE: return "PSA_ERROR_HARDWARE_FAILURE";
    case PSA_ERROR_INSUFFICIENT_CAPACITY: return "PSA_ERROR_INSUFFICIENT_CAPACITY";
    case PSA_ERROR_INSUFFICIENT_ENTROPY: return "PSA_ERROR_INSUFFICIENT_ENTROPY";
    case PSA_ERROR_INSUFFICIENT_MEMORY: return "PSA_ERROR_INSUFFICIENT_MEMORY";
    case PSA_ERROR_INSUFFICIENT_STORAGE: return "PSA_ERROR_INSUFFICIENT_STORAGE";
    case PSA_ERROR_INVALID_ARGUMENT: return "PSA_ERROR_INVALID_ARGUMENT";
    case PSA_ERROR_INVALID_HANDLE: return "PSA_ERROR_INVALID_HANDLE";
    case PSA_ERROR_INVALID_PADDING: return "PSA_ERROR_INVALID_PADDING";
    case PSA_ERROR_INVALID_SIGNATURE: return "PSA_ERROR_INVALID_SIGNATURE";
    case PSA_ERROR_NOT_PERMITTED: return "PSA_ERROR_NOT_PERMITTED";
    case PSA_ERROR_NOT_SUPPORTED: return "PSA_ERROR_NOT_SUPPORTED";
    case PSA_ERROR_OCCUPIED_SLOT: return "PSA_ERROR_OCCUPIED_SLOT";
    case PSA_ERROR_STORAGE_FAILURE: return "PSA_ERROR_STORAGE_FAILURE";
    case PSA_ERROR_TAMPERING_DETECTED: return "PSA_ERROR_TAMPERING_DETECTED";
    case PSA_ERROR_UNKNOWN_ERROR: return "PSA_ERROR_UNKNOWN_ERROR";
    case PSA_SUCCESS: return "PSA_SUCCESS";
    default: return NULL;
    }
}

static const char *psa_ecc_curve_name(psa_ecc_curve_t curve)
{
    switch (curve) {
    case PSA_ECC_CURVE_BRAINPOOL_P256R1: return "PSA_ECC_CURVE_BRAINPOOL_P256R1";
    case PSA_ECC_CURVE_BRAINPOOL_P384R1: return "PSA_ECC_CURVE_BRAINPOOL_P384R1";
    case PSA_ECC_CURVE_BRAINPOOL_P512R1: return "PSA_ECC_CURVE_BRAINPOOL_P512R1";
    case PSA_ECC_CURVE_CURVE25519: return "PSA_ECC_CURVE_CURVE25519";
    case PSA_ECC_CURVE_CURVE448: return "PSA_ECC_CURVE_CURVE448";
    case PSA_ECC_CURVE_SECP160K1: return "PSA_ECC_CURVE_SECP160K1";
    case PSA_ECC_CURVE_SECP160R1: return "PSA_ECC_CURVE_SECP160R1";
    case PSA_ECC_CURVE_SECP160R2: return "PSA_ECC_CURVE_SECP160R2";
    case PSA_ECC_CURVE_SECP192K1: return "PSA_ECC_CURVE_SECP192K1";
    case PSA_ECC_CURVE_SECP192R1: return "PSA_ECC_CURVE_SECP192R1";
    case PSA_ECC_CURVE_SECP224K1: return "PSA_ECC_CURVE_SECP224K1";
    case PSA_ECC_CURVE_SECP224R1: return "PSA_ECC_CURVE_SECP224R1";
    case PSA_ECC_CURVE_SECP256K1: return "PSA_ECC_CURVE_SECP256K1";
    case PSA_ECC_CURVE_SECP256R1: return "PSA_ECC_CURVE_SECP256R1";
    case PSA_ECC_CURVE_SECP384R1: return "PSA_ECC_CURVE_SECP384R1";
    case PSA_ECC_CURVE_SECP521R1: return "PSA_ECC_CURVE_SECP521R1";
    case PSA_ECC_CURVE_SECT163K1: return "PSA_ECC_CURVE_SECT163K1";
    case PSA_ECC_CURVE_SECT163R1: return "PSA_ECC_CURVE_SECT163R1";
    case PSA_ECC_CURVE_SECT163R2: return "PSA_ECC_CURVE_SECT163R2";
    case PSA_ECC_CURVE_SECT193R1: return "PSA_ECC_CURVE_SECT193R1";
    case PSA_ECC_CURVE_SECT193R2: return "PSA_ECC_CURVE_SECT193R2";
    case PSA_ECC_CURVE_SECT233K1: return "PSA_ECC_CURVE_SECT233K1";
    case PSA_ECC_CURVE_SECT233R1: return "PSA_ECC_CURVE_SECT233R1";
    case PSA_ECC_CURVE_SECT239K1: return "PSA_ECC_CURVE_SECT239K1";
    case PSA_ECC_CURVE_SECT283K1: return "PSA_ECC_CURVE_SECT283K1";
    case PSA_ECC_CURVE_SECT283R1: return "PSA_ECC_CURVE_SECT283R1";
    case PSA_ECC_CURVE_SECT409K1: return "PSA_ECC_CURVE_SECT409K1";
    case PSA_ECC_CURVE_SECT409R1: return "PSA_ECC_CURVE_SECT409R1";
    case PSA_ECC_CURVE_SECT571K1: return "PSA_ECC_CURVE_SECT571K1";
    case PSA_ECC_CURVE_SECT571R1: return "PSA_ECC_CURVE_SECT571R1";
    default: return NULL;
    }
}

static const char *psa_hash_algorithm_name(psa_algorithm_t hash_alg)
{
    switch (hash_alg) {
    case PSA_ALG_CATEGORY_HASH: return "PSA_ALG_CATEGORY_HASH";
    case PSA_ALG_MD2: return "PSA_ALG_MD2";
    case PSA_ALG_MD4: return "PSA_ALG_MD4";
    case PSA_ALG_MD5: return "PSA_ALG_MD5";
    case PSA_ALG_RIPEMD160: return "PSA_ALG_RIPEMD160";
    case PSA_ALG_SHA3_224: return "PSA_ALG_SHA3_224";
    case PSA_ALG_SHA3_256: return "PSA_ALG_SHA3_256";
    case PSA_ALG_SHA3_384: return "PSA_ALG_SHA3_384";
    case PSA_ALG_SHA3_512: return "PSA_ALG_SHA3_512";
    case PSA_ALG_SHA_1: return "PSA_ALG_SHA_1";
    case PSA_ALG_SHA_224: return "PSA_ALG_SHA_224";
    case PSA_ALG_SHA_256: return "PSA_ALG_SHA_256";
    case PSA_ALG_SHA_384: return "PSA_ALG_SHA_384";
    case PSA_ALG_SHA_512: return "PSA_ALG_SHA_512";
    case PSA_ALG_SHA_512_224: return "PSA_ALG_SHA_512_224";
    case PSA_ALG_SHA_512_256: return "PSA_ALG_SHA_512_256";
    default: return NULL;
    }
}

static int psa_snprint_key_type(char *buffer, size_t buffer_size,
                                psa_key_type_t type)
{
    size_t required_size = 0;
    switch (type) {
    case PSA_KEY_TYPE_AES: append(&buffer, buffer_size, &required_size, "PSA_KEY_TYPE_AES", 16); break;
    case PSA_KEY_TYPE_ARC4: append(&buffer, buffer_size, &required_size, "PSA_KEY_TYPE_ARC4", 17); break;
    case PSA_KEY_TYPE_CAMELLIA: append(&buffer, buffer_size, &required_size, "PSA_KEY_TYPE_CAMELLIA", 21); break;
    case PSA_KEY_TYPE_CATEGORY_FLAG_PAIR: append(&buffer, buffer_size, &required_size, "PSA_KEY_TYPE_CATEGORY_FLAG_PAIR", 31); break;
    case PSA_KEY_TYPE_CATEGORY_KEY_PAIR: append(&buffer, buffer_size, &required_size, "PSA_KEY_TYPE_CATEGORY_KEY_PAIR", 30); break;
    case PSA_KEY_TYPE_CATEGORY_PUBLIC_KEY: append(&buffer, buffer_size, &required_size, "PSA_KEY_TYPE_CATEGORY_PUBLIC_KEY", 32); break;
    case PSA_KEY_TYPE_CATEGORY_RAW: append(&buffer, buffer_size, &required_size, "PSA_KEY_TYPE_CATEGORY_RAW", 25); break;
    case PSA_KEY_TYPE_CATEGORY_SYMMETRIC: append(&buffer, buffer_size, &required_size, "PSA_KEY_TYPE_CATEGORY_SYMMETRIC", 31); break;
    case PSA_KEY_TYPE_DERIVE: append(&buffer, buffer_size, &required_size, "PSA_KEY_TYPE_DERIVE", 19); break;
    case PSA_KEY_TYPE_DES: append(&buffer, buffer_size, &required_size, "PSA_KEY_TYPE_DES", 16); break;
    case PSA_KEY_TYPE_DSA_KEYPAIR: append(&buffer, buffer_size, &required_size, "PSA_KEY_TYPE_DSA_KEYPAIR", 24); break;
    case PSA_KEY_TYPE_DSA_PUBLIC_KEY: append(&buffer, buffer_size, &required_size, "PSA_KEY_TYPE_DSA_PUBLIC_KEY", 27); break;
    case PSA_KEY_TYPE_ECC_KEYPAIR_BASE: append(&buffer, buffer_size, &required_size, "PSA_KEY_TYPE_ECC_KEYPAIR_BASE", 29); break;
    case PSA_KEY_TYPE_ECC_PUBLIC_KEY_BASE: append(&buffer, buffer_size, &required_size, "PSA_KEY_TYPE_ECC_PUBLIC_KEY_BASE", 32); break;
    case PSA_KEY_TYPE_HMAC: append(&buffer, buffer_size, &required_size, "PSA_KEY_TYPE_HMAC", 17); break;
    case PSA_KEY_TYPE_NONE: append(&buffer, buffer_size, &required_size, "PSA_KEY_TYPE_NONE", 17); break;
    case PSA_KEY_TYPE_RAW_DATA: append(&buffer, buffer_size, &required_size, "PSA_KEY_TYPE_RAW_DATA", 21); break;
    case PSA_KEY_TYPE_RSA_KEYPAIR: append(&buffer, buffer_size, &required_size, "PSA_KEY_TYPE_RSA_KEYPAIR", 24); break;
    case PSA_KEY_TYPE_RSA_PUBLIC_KEY: append(&buffer, buffer_size, &required_size, "PSA_KEY_TYPE_RSA_PUBLIC_KEY", 27); break;
    default:
        if (PSA_KEY_TYPE_IS_ECC_KEYPAIR(type)) {
            append_with_curve(&buffer, buffer_size, &required_size,
                              "PSA_KEY_TYPE_ECC_KEYPAIR", 24,
                              PSA_KEY_TYPE_GET_CURVE(type));
        } else if (PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY(type)) {
            append_with_curve(&buffer, buffer_size, &required_size,
                              "PSA_KEY_TYPE_ECC_PUBLIC_KEY", 27,
                              PSA_KEY_TYPE_GET_CURVE(type));
        } else {
            return snprintf(buffer, buffer_size,
                            "0x%08lx", (unsigned long) type);
        }
        break;
    }
    buffer[0] = 0;
    return (int) required_size;
}

static int psa_snprint_algorithm(char *buffer, size_t buffer_size,
                                 psa_algorithm_t alg)
{
    size_t required_size = 0;
    psa_algorithm_t core_alg = alg;
    unsigned long length_modifier = 0;
    if (PSA_ALG_IS_MAC(alg)) {
        core_alg = PSA_ALG_TRUNCATED_MAC(alg, 0);
        if (core_alg != alg) {
            append(&buffer, buffer_size, &required_size,
                   "PSA_ALG_TRUNCATED_MAC(", 22);
            length_modifier = PSA_MAC_TRUNCATED_LENGTH(alg);
        }
    } else if (PSA_ALG_IS_AEAD(alg)) {
        core_alg = PSA_ALG_AEAD_WITH_DEFAULT_TAG_LENGTH(alg);
        if (core_alg != alg) {
            append(&buffer, buffer_size, &required_size,
                   "PSA_ALG_AEAD_WITH_TAG_LENGTH(", 29);
            length_modifier = PSA_AEAD_TAG_LENGTH(alg);
        }
    }
    switch (core_alg) {
    case PSA_ALG_ARC4: append(&buffer, buffer_size, &required_size, "PSA_ALG_ARC4", 12); break;
    case PSA_ALG_CATEGORY_AEAD: append(&buffer, buffer_size, &required_size, "PSA_ALG_CATEGORY_AEAD", 21); break;
    case PSA_ALG_CATEGORY_ASYMMETRIC_ENCRYPTION: append(&buffer, buffer_size, &required_size, "PSA_ALG_CATEGORY_ASYMMETRIC_ENCRYPTION", 38); break;
    case PSA_ALG_CATEGORY_CIPHER: append(&buffer, buffer_size, &required_size, "PSA_ALG_CATEGORY_CIPHER", 23); break;
    case PSA_ALG_CATEGORY_HASH: append(&buffer, buffer_size, &required_size, "PSA_ALG_CATEGORY_HASH", 21); break;
    case PSA_ALG_CATEGORY_KEY_AGREEMENT: append(&buffer, buffer_size, &required_size, "PSA_ALG_CATEGORY_KEY_AGREEMENT", 30); break;
    case PSA_ALG_CATEGORY_KEY_DERIVATION: append(&buffer, buffer_size, &required_size, "PSA_ALG_CATEGORY_KEY_DERIVATION", 31); break;
    case PSA_ALG_CATEGORY_KEY_SELECTION: append(&buffer, buffer_size, &required_size, "PSA_ALG_CATEGORY_KEY_SELECTION", 30); break;
    case PSA_ALG_CATEGORY_MAC: append(&buffer, buffer_size, &required_size, "PSA_ALG_CATEGORY_MAC", 20); break;
    case PSA_ALG_CATEGORY_SIGN: append(&buffer, buffer_size, &required_size, "PSA_ALG_CATEGORY_SIGN", 21); break;
    case PSA_ALG_CBC_MAC: append(&buffer, buffer_size, &required_size, "PSA_ALG_CBC_MAC", 15); break;
    case PSA_ALG_CBC_NO_PADDING: append(&buffer, buffer_size, &required_size, "PSA_ALG_CBC_NO_PADDING", 22); break;
    case PSA_ALG_CBC_PKCS7: append(&buffer, buffer_size, &required_size, "PSA_ALG_CBC_PKCS7", 17); break;
    case PSA_ALG_CCM: append(&buffer, buffer_size, &required_size, "PSA_ALG_CCM", 11); break;
    case PSA_ALG_CFB: append(&buffer, buffer_size, &required_size, "PSA_ALG_CFB", 11); break;
    case PSA_ALG_CIPHER_MAC_BASE: append(&buffer, buffer_size, &required_size, "PSA_ALG_CIPHER_MAC_BASE", 23); break;
    case PSA_ALG_CMAC: append(&buffer, buffer_size, &required_size, "PSA_ALG_CMAC", 12); break;
    case PSA_ALG_CTR: append(&buffer, buffer_size, &required_size, "PSA_ALG_CTR", 11); break;
    case PSA_ALG_DETERMINISTIC_DSA_BASE: append(&buffer, buffer_size, &required_size, "PSA_ALG_DETERMINISTIC_DSA_BASE", 30); break;
    case PSA_ALG_DETERMINISTIC_ECDSA_BASE: append(&buffer, buffer_size, &required_size, "PSA_ALG_DETERMINISTIC_ECDSA_BASE", 32); break;
    case PSA_ALG_DSA_BASE: append(&buffer, buffer_size, &required_size, "PSA_ALG_DSA_BASE", 16); break;
    case PSA_ALG_ECDH_BASE: append(&buffer, buffer_size, &required_size, "PSA_ALG_ECDH_BASE", 17); break;
    case PSA_ALG_ECDSA_ANY: append(&buffer, buffer_size, &required_size, "PSA_ALG_ECDSA_ANY", 17); break;
    case PSA_ALG_FFDH_BASE: append(&buffer, buffer_size, &required_size, "PSA_ALG_FFDH_BASE", 17); break;
    case PSA_ALG_GCM: append(&buffer, buffer_size, &required_size, "PSA_ALG_GCM", 11); break;
    case PSA_ALG_GMAC: append(&buffer, buffer_size, &required_size, "PSA_ALG_GMAC", 12); break;
    case PSA_ALG_HKDF_BASE: append(&buffer, buffer_size, &required_size, "PSA_ALG_HKDF_BASE", 17); break;
    case PSA_ALG_HMAC_BASE: append(&buffer, buffer_size, &required_size, "PSA_ALG_HMAC_BASE", 17); break;
    case PSA_ALG_MD2: append(&buffer, buffer_size, &required_size, "PSA_ALG_MD2", 11); break;
    case PSA_ALG_MD4: append(&buffer, buffer_size, &required_size, "PSA_ALG_MD4", 11); break;
    case PSA_ALG_MD5: append(&buffer, buffer_size, &required_size, "PSA_ALG_MD5", 11); break;
    case PSA_ALG_OFB: append(&buffer, buffer_size, &required_size, "PSA_ALG_OFB", 11); break;
    case PSA_ALG_RIPEMD160: append(&buffer, buffer_size, &required_size, "PSA_ALG_RIPEMD160", 17); break;
    case PSA_ALG_RSA_OAEP_BASE: append(&buffer, buffer_size, &required_size, "PSA_ALG_RSA_OAEP_BASE", 21); break;
    case PSA_ALG_RSA_PKCS1V15_CRYPT: append(&buffer, buffer_size, &required_size, "PSA_ALG_RSA_PKCS1V15_CRYPT", 26); break;
    case PSA_ALG_RSA_PKCS1V15_SIGN_RAW: append(&buffer, buffer_size, &required_size, "PSA_ALG_RSA_PKCS1V15_SIGN_RAW", 29); break;
    case PSA_ALG_RSA_PSS_BASE: append(&buffer, buffer_size, &required_size, "PSA_ALG_RSA_PSS_BASE", 20); break;
    case PSA_ALG_SELECT_RAW: append(&buffer, buffer_size, &required_size, "PSA_ALG_SELECT_RAW", 18); break;
    case PSA_ALG_SHA3_224: append(&buffer, buffer_size, &required_size, "PSA_ALG_SHA3_224", 16); break;
    case PSA_ALG_SHA3_256: append(&buffer, buffer_size, &required_size, "PSA_ALG_SHA3_256", 16); break;
    case PSA_ALG_SHA3_384: append(&buffer, buffer_size, &required_size, "PSA_ALG_SHA3_384", 16); break;
    case PSA_ALG_SHA3_512: append(&buffer, buffer_size, &required_size, "PSA_ALG_SHA3_512", 16); break;
    case PSA_ALG_SHA_1: append(&buffer, buffer_size, &required_size, "PSA_ALG_SHA_1", 13); break;
    case PSA_ALG_SHA_224: append(&buffer, buffer_size, &required_size, "PSA_ALG_SHA_224", 15); break;
    case PSA_ALG_SHA_256: append(&buffer, buffer_size, &required_size, "PSA_ALG_SHA_256", 15); break;
    case PSA_ALG_SHA_384: append(&buffer, buffer_size, &required_size, "PSA_ALG_SHA_384", 15); break;
    case PSA_ALG_SHA_512: append(&buffer, buffer_size, &required_size, "PSA_ALG_SHA_512", 15); break;
    case PSA_ALG_SHA_512_224: append(&buffer, buffer_size, &required_size, "PSA_ALG_SHA_512_224", 19); break;
    case PSA_ALG_SHA_512_256: append(&buffer, buffer_size, &required_size, "PSA_ALG_SHA_512_256", 19); break;
    case PSA_ALG_TLS12_PRF_BASE: append(&buffer, buffer_size, &required_size, "PSA_ALG_TLS12_PRF_BASE", 22); break;
    case PSA_ALG_TLS12_PSK_TO_MS_BASE: append(&buffer, buffer_size, &required_size, "PSA_ALG_TLS12_PSK_TO_MS_BASE", 28); break;
    case PSA_ALG_XTS: append(&buffer, buffer_size, &required_size, "PSA_ALG_XTS", 11); break;
    default:
        if (PSA_ALG_IS_DETERMINISTIC_DSA(core_alg)) {
            append_with_hash(&buffer, buffer_size, &required_size,
                             "PSA_ALG_DETERMINISTIC_DSA", 25,
                             PSA_ALG_GET_HASH(core_alg));
        } else if (PSA_ALG_IS_DETERMINISTIC_ECDSA(core_alg)) {
            append_with_hash(&buffer, buffer_size, &required_size,
                             "PSA_ALG_DETERMINISTIC_ECDSA", 27,
                             PSA_ALG_GET_HASH(core_alg));
        } else if (PSA_ALG_IS_RANDOMIZED_DSA(core_alg)) {
            append_with_hash(&buffer, buffer_size, &required_size,
                             "PSA_ALG_DSA", 11,
                             PSA_ALG_GET_HASH(core_alg));
        } else if (PSA_ALG_IS_RANDOMIZED_ECDSA(core_alg)) {
            append_with_hash(&buffer, buffer_size, &required_size,
                             "PSA_ALG_ECDSA", 13,
                             PSA_ALG_GET_HASH(core_alg));
        } else if (PSA_ALG_IS_HKDF(core_alg)) {
            append_with_hash(&buffer, buffer_size, &required_size,
                             "PSA_ALG_HKDF", 12,
                             PSA_ALG_GET_HASH(core_alg));
        } else if (PSA_ALG_IS_HMAC(core_alg)) {
            append_with_hash(&buffer, buffer_size, &required_size,
                             "PSA_ALG_HMAC", 12,
                             PSA_ALG_GET_HASH(core_alg));
        } else if (PSA_ALG_IS_RSA_OAEP(core_alg)) {
            append_with_hash(&buffer, buffer_size, &required_size,
                             "PSA_ALG_RSA_OAEP", 16,
                             PSA_ALG_GET_HASH(core_alg));
        } else if (PSA_ALG_IS_RSA_PKCS1V15_SIGN(core_alg)) {
            append_with_hash(&buffer, buffer_size, &required_size,
                             "PSA_ALG_RSA_PKCS1V15_SIGN", 25,
                             PSA_ALG_GET_HASH(core_alg));
        } else if (PSA_ALG_IS_RSA_PSS(core_alg)) {
            append_with_hash(&buffer, buffer_size, &required_size,
                             "PSA_ALG_RSA_PSS", 15,
                             PSA_ALG_GET_HASH(core_alg));
        } else if (PSA_ALG_IS_TLS12_PRF(core_alg)) {
            append_with_hash(&buffer, buffer_size, &required_size,
                             "PSA_ALG_TLS12_PRF", 17,
                             PSA_ALG_GET_HASH(core_alg));
        } else if (PSA_ALG_IS_TLS12_PSK_TO_MS(core_alg)) {
            append_with_hash(&buffer, buffer_size, &required_size,
                             "PSA_ALG_TLS12_PSK_TO_MS", 23,
                             PSA_ALG_GET_HASH(core_alg));
        } else {
            append_integer(&buffer, buffer_size, &required_size,
                           "0x%08lx", (unsigned long) alg);
        }
        break;
    }
    if (core_alg != alg) {
        append(&buffer, buffer_size, &required_size, ", ", 2);
        append_integer(&buffer, buffer_size, &required_size,
                       "%lu", length_modifier);
        append(&buffer, buffer_size, &required_size, ")", 1);
    }
    buffer[0] = 0;
    return (int) required_size;
}

static int psa_snprint_key_usage(char *buffer, size_t buffer_size,
                                 psa_key_usage_t usage)
{
    size_t required_size = 0;
    if (usage == 0) {
        if (buffer_size > 1) {
            buffer[0] = '0';
            buffer[1] = 0;
        } else if (buffer_size == 1) {
            buffer[0] = 0;
        }
        return 1;
    }
    if (usage & PSA_KEY_USAGE_DECRYPT) {
        if (required_size != 0) {
            append(&buffer, buffer_size, &required_size, " | ", 3);
        }
        append(&buffer, buffer_size, &required_size, "PSA_KEY_USAGE_DECRYPT", 21);
        usage ^= PSA_KEY_USAGE_DECRYPT;
    }
    if (usage & PSA_KEY_USAGE_DERIVE) {
        if (required_size != 0) {
            append(&buffer, buffer_size, &required_size, " | ", 3);
        }
        append(&buffer, buffer_size, &required_size, "PSA_KEY_USAGE_DERIVE", 20);
        usage ^= PSA_KEY_USAGE_DERIVE;
    }
    if (usage & PSA_KEY_USAGE_ENCRYPT) {
        if (required_size != 0) {
            append(&buffer, buffer_size, &required_size, " | ", 3);
        }
        append(&buffer, buffer_size, &required_size, "PSA_KEY_USAGE_ENCRYPT", 21);
        usage ^= PSA_KEY_USAGE_ENCRYPT;
    }
    if (usage & PSA_KEY_USAGE_EXPORT) {
        if (required_size != 0) {
            append(&buffer, buffer_size, &required_size, " | ", 3);
        }
        append(&buffer, buffer_size, &required_size, "PSA_KEY_USAGE_EXPORT", 20);
        usage ^= PSA_KEY_USAGE_EXPORT;
    }
    if (usage & PSA_KEY_USAGE_SIGN) {
        if (required_size != 0) {
            append(&buffer, buffer_size, &required_size, " | ", 3);
        }
        append(&buffer, buffer_size, &required_size, "PSA_KEY_USAGE_SIGN", 18);
        usage ^= PSA_KEY_USAGE_SIGN;
    }
    if (usage & PSA_KEY_USAGE_VERIFY) {
        if (required_size != 0) {
            append(&buffer, buffer_size, &required_size, " | ", 3);
        }
        append(&buffer, buffer_size, &required_size, "PSA_KEY_USAGE_VERIFY", 20);
        usage ^= PSA_KEY_USAGE_VERIFY;
    }
    if (usage != 0) {
        if (required_size != 0) {
            append(&buffer, buffer_size, &required_size, " | ", 3);
        }
        append_integer(&buffer, buffer_size, &required_size,
                       "0x%08lx", (unsigned long) usage);
    } else {
        buffer[0] = 0;
    }
    return (int) required_size;
}

/* End of automatically generated file. */
